package com.redhat.consulting.transaction.api;

import com.redhat.consulting.transaction.model.PageMetadata;
import org.apache.commons.collections4.ListUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.util.Optional.ofNullable;

/**
 * Static support methods for handling {@link Pageable} with APIs generated by OpenAPI Generator.
 */
public final class PageableApiUtil {

    private static final int DEFAULT_PAGE = 0;
    private static final int DEFAULT_SIZE = 20;

    private PageableApiUtil() {
    }

    /**
     * Parse generated OpenAPI parameters into a usable Spring {@link Pageable} object, similar
     * to how one would be generated when using Spring MVC
     *
     * @param sort    the sort parameter from a list request, preferably from the
     *                {@link org.springframework.web.context.request.NativeWebRequest} directly to avoid Spring
     *                splitting a single "sort=" parameters on its commas
     * @param page    the page parameter from a list request
     * @param size    the size parameter from a list request
     * @param unpaged the unpaged parameter from a list request
     * @return a {@link Pageable} object for use with Spring Data
     */
    public static Pageable parsePageable(List<String> sort, Integer page, Integer size, Boolean unpaged) {
        Pageable pageable;
        if (Boolean.TRUE.equals(unpaged)) {
            pageable = Pageable.unpaged();
        } else {
            pageable = PageRequest.of(ofNullable(page).orElse(DEFAULT_PAGE),
                    ofNullable(size).orElse(DEFAULT_SIZE),
                    Sort.by(ListUtils.emptyIfNull(sort).stream()
                            .flatMap(sortRequest -> {
                                String[] sortSplits = sortRequest.split(",");
                                Function<String, Sort.Order> toOrder;
                                int lastSplit = sortSplits.length - 1;
                                if (StringUtils.equalsIgnoreCase("asc", sortSplits[lastSplit])) {
                                    toOrder = Sort.Order::asc;
                                } else if (StringUtils.equalsIgnoreCase("desc", sortSplits[lastSplit])) {
                                    toOrder = Sort.Order::desc;
                                } else {
                                    lastSplit++;
                                    toOrder = Sort.Order::by;
                                }

                                return Stream
                                        .of(ArrayUtils.subarray(sortSplits, 0, lastSplit))
                                        .map(toOrder);
                            })
                            .collect(Collectors.toList())));
        }

        return pageable;
    }

    /**
     * Copy metadata from {@link Page} objects into a new {@link PageMetadata} object
     *
     * @param source the Spring {@link Page} of data that will be returned
     * @return a new {@link PageMetadata} object containing the same metadata from the page
     */
    public static PageMetadata createPageMetadata(Page<?> source) {
        return new PageMetadata()
                .number(source.getNumber())
                .size(source.getSize())
                .totalPages(source.getTotalPages())
                .totalElements(source.getNumberOfElements());
    }

}
